# Resolve react_native_pods.rb with node to allow for hoisting
# Define o caminho para a raiz do projeto (um nível acima do diretório do Podfile)
project_root = File.expand_path('..', __dir__)

# Script Node.js mais robusto para encontrar react_native_pods.rb
node_script_to_find_pods_rb = <<~JAVASCRIPT
  try {
    // process.argv[1] será o project_root passado pelo Ruby
    const baseDir = process.argv[1];
    const rnPackageJsonPath = require.resolve('react-native/package.json', { paths: [baseDir] });
    const rnRootPath = require('path').dirname(rnPackageJsonPath);
    const scriptPath = require('path').join(rnRootPath, 'scripts/react_native_pods.rb');
    if (require('fs').existsSync(scriptPath)) {
      process.stdout.write(scriptPath);
    } else {
      // Tenta um caminho alternativo comum se o primeiro falhar (ex: monorepos)
      const alternativeScriptPath = require('path').join(baseDir, 'node_modules/react-native/scripts/react_native_pods.rb');
      if (require('fs').existsSync(alternativeScriptPath)) {
        process.stdout.write(alternativeScriptPath);
      } else {
        process.stderr.write("Script react_native_pods.rb não encontrado em: " + scriptPath + " ou " + alternativeScriptPath + "\\n");
        process.exit(1);
      }
    }
  } catch (e) {
    process.stderr.write("Erro ao tentar localizar react_native_pods.rb: " + e.message + "\\n");
    process.exit(1); // Sai com erro para indicar falha
  }
JAVASCRIPT

react_native_pods_script_output = ""
begin
  react_native_pods_script_output = Pod::Executable.execute_command('node', ['-e', node_script_to_find_pods_rb, project_root]).strip
rescue Pod::PlainInformative => e
  Pod::UI.warn "Falha ao executar script Node.js para encontrar react_native_pods.rb: #{e.message}"
end

min_ios_version_supported_from_script = nil
if !react_native_pods_script_output.empty? && File.exist?(react_native_pods_script_output)
  begin
    require react_native_pods_script_output
    # Tenta obter a variável se ela for definida pelo script
    min_ios_version_supported_from_script = min_ios_version_supported if defined?(min_ios_version_supported)
  rescue Exception => e
     Pod::UI.warn "Erro ao carregar #{react_native_pods_script_output}: #{e.message}"
  end
else
  Pod::UI.warn "Não foi possível encontrar ou carregar react-native/scripts/react_native_pods.rb."
  Pod::UI.warn "Verifique se 'react-native' está instalado corretamente em 'node_modules' na raiz do projeto: #{project_root}"
end

# Defina a sua versão mínima do iOS aqui.
# Usa a variável do script se disponível, caso contrário, um valor padrão.
ios_version = min_ios_version_supported_from_script || '13.0'
platform :ios, ios_version

# Adicionado para resolver problemas de "module not found" e "Swift pods cannot yet be integrated as static libraries"
use_modular_headers!

# Se prepare_react_native_project! for um método definido pelo script carregado acima,
# ele deve estar disponível aqui. Caso contrário, esta linha pode precisar ser removida ou ajustada
# dependendo do que o script react_native_pods.rb realmente faz.
# Se o script não definir este método, e ele não for de outra fonte, esta linha causará erro.
# Para um Podfile gerado pelo `expo prebuild`, esta linha é geralmente adicionada.
prepare_react_native_project! if defined?(prepare_react_native_project!)


linkage = ENV['USE_FRAMEWORKS']
if linkage != nil
  Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
  use_frameworks! :linkage => linkage.to_sym
end

target 'PagaAMustarda' do # Certifique-se de que 'PagaAMustarda' é o nome correto do seu target
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  post_install do |installer|
    # Chamada original do React Native para post_install
    # Verifique se react_native_post_install está definido antes de chamar
    if defined?(react_native_post_install)
      react_native_post_install(
        installer,
        config[:reactNativePath], # Passa o reactNativePath obtido de use_native_modules!
        :mac_catalyst_enabled => false
      )
    else
      Pod::UI.warn "Função react_native_post_install não definida. Verifique o script react_native_pods.rb."
    end

    installer.pods_project.targets.each do |target|
      # ---- CÓDIGO PARA O gRPC-Core ----
      if target.name == 'gRPC-Core' || target.name.downcase.start_with?('grpc-core')
        target.build_configurations.each do |config|
          config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
          config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'GRPC_CFSTREAM=0'
          
          grpc_header_search_paths = [
            '$(PODS_ROOT)/gRPC-Core/include',
            '$(PODS_ROOT)/gRPC-Core/src/core/lib/surface',
            '$(PODS_ROOT)/gRPC-Core/src/core/lib/channel',
            '$(PODS_ROOT)/gRPC-Core/src/core/lib/gpr',
            '$(PODS_TARGET_SRCROOT)/src/core/lib/surface',
            '$(PODS_TARGET_SRCROOT)/src/core/lib/channel',
            '$(PODS_TARGET_SRCROOT)/src/core/lib/gpr',
            '$(PODS_TARGET_SRCROOT)/include'
          ].uniq
          
          existing_paths = config.build_settings['HEADER_SEARCH_PATHS'] || ['$(inherited)']
          existing_paths = [existing_paths] if existing_paths.is_a?(String)
          config.build_settings['HEADER_SEARCH_PATHS'] = (existing_paths + grpc_header_search_paths).uniq.compact
        end
      end

      # ---- CÓDIGO PARA O gRPC-C++ (Para encontrar o modulemap do gRPC-Core) ----
      if target.name == 'gRPC-C++'
        target.build_configurations.each do |config|
          grpc_cpp_header_search_paths = [
            '"$(PODS_ROOT)/Headers/Private"',
            '"$(PODS_ROOT)/Headers/Public"'
          ].uniq

          existing_paths = config.build_settings['HEADER_SEARCH_PATHS'] || ['$(inherited)']
          existing_paths = [existing_paths] if existing_paths.is_a?(String)
          config.build_settings['HEADER_SEARCH_PATHS'] = (existing_paths + grpc_cpp_header_search_paths).uniq.compact
        end
      end

      # ---- CÓDIGO PARA PERMITIR NON-MODULAR INCLUDES EM TARGETS ESPECÍFICOS ----
      targets_requiring_non_modular_includes = [
        'React-Core', 'ReactCommon', 'React-RCTAnimation', 'React-RCTBlob',
        'React-RCTImage', 'React-RCTLinking', 'React-RCTNetwork', 'React-RCTSettings',
        'React-RCTText', 'React-RCTVibration', 'React-CoreModules', 'React-CoreLocation',
        'React-cxxreact', 'React-jsi', 'React-jsiexecutor', 'React-jsinspector',
        'React-perflogger', 'React-NativeModulesApple', 'React-Fabric', 'React-graphics',
        'React-utils', 'DoubleConversion', 'fmt', 'folly', 'glog', 'boost', 'Flipper',
        'Flipper-Boost-iOSX', 'Flipper-DoubleConversion', 'Flipper-Fmt', 'Flipper-Folly',
        'Flipper-Glog', 'Flipper-PeerTalk', 'Flipper-RSocket', 'Yoga',
        'BoringSSL-GRPC',
        'gRPC-C++' # Adicionado gRPC-C++ a esta lista também
      ]

      if targets_requiring_non_modular_includes.include?(target.name) || 
         target.name.start_with?('React') || 
         target.name.start_with?('react-')
        target.build_configurations.each do |config|
          config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
        end
      end
    end
  end
end
